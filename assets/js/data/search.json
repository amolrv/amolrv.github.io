[ { "title": "Harnessing power of multi-paradigm", "url": "/posts/mpp/", "categories": "Programming", "tags": "", "date": "2023-09-07 00:00:00 +0530", "snippet": "Harnessing power of multi-paradigmModern languages such as fsharp, swift, rust and Kotlin supports multiple programming paradigms, allowing developers to leverage the strengths of different approaches.Rust: combines imperative, functional, and object-oriented paradigms.Swift: imperative, object-oriented programming paradigms and incorporates functional programming features.Kotlin: object-oriented and functional programming paradigmsPlease note each languages varies at degree at which they support given paradigm and might have their own nuances.Programming paradigms Declarative ==functional== logic reactive Imperative procedural ==object oriented== Declarative paradigm focuses on ‚Äúwhat‚Äù rather than ‚Äúhow‚Äù. This one thing along bring ton of benefits on table. This become even more powerful when fused with [[Clear and honest code block]] Single responsibility principle Composition ImmutabilityImperative coding style focuses on ‚Äúhow‚Äù rather than ‚Äúwhat‚Äù. Offers greater controls over each steps Less indirectionsLet‚Äôs take a simple example in Kotlin.class BirthdayNotifier( private val contactService: ContactService, private val notificationService: NotificationService, private val metricService: MetricService) { fun notify(user: UUID) { val birthdayBuddies = contactService.findFriendsOf(user) .filter { contact -&gt; contact.birthDate?.isToday() ?: false } .also { logger.info { \"${it.count()} people from your contact have Birthday today\" } } .toList() var failedToNotify = 0 birthdayBuddies.forEach { contact -&gt; try { val isAlreadyNotified = notificationService .findNotification(contact) .filterNot { notification -&gt; notification.time.toLocalDate().isToday() &amp;&amp; (notification.notification is BirthdayNotification) } .any() if (isAlreadyNotified) logger.info { \"Already notified\" } else { val notification = BirthdayNotification.from(contact) notificationService.notify(notification) logger.info { \"Notified about birthday\" } } } catch (ex: Throwable) { logger.error(ex) { \"Failed to notify contact $contact\" } failedToNotify += 1 } } if (failedToNotify &gt; 0) metricService.measureCount(\"birthday.nofitication.failed.count\", failedToNotify) }}Author naturally gravitates towards ‚Äúhow to do things‚Äù rather than ‚Äúwhat are we doing here‚Äù during writing phaseWhile reader always seek for ‚Äúwhat are we doing here‚Äù and want to form mental model of the system.Once we understand objectives of Authors and Readers, we can address needs according.We can use declarative style when it‚Äôs what is more important than how.when it‚Äôs about doing one thing and main question is about ‚Äúhow‚Äù rather than ‚Äúwhat‚Äù go for imperative style with and keep focus on efficiency.At high level, we‚Äôre finding buddies who have birthday and which aren‚Äôt yet notified yet Once we found such buddies we‚Äôre notifying them Lastly reporting failed to notified countBut above code does not look or speak this clear. Let‚Äôs write code at this level of abstraction and see how it looks.// other codefun notify(user: UUID) { birthdayBuddiesOf(user) .filterNot(::alreadyNotified) .map(::BirthdayNotification) .map(::sendNotification) .let{ notificationResults -&gt; notificationResults.count { it.isFailure } } .also(::recordMetric) } private fun birthdayBuddiesOf(userId: UUID): List&lt;Contact&gt; = contactService.findFriendsOf(userId) .filter { contact -&gt; contact.birthDate?.isToday() ?: false } .also { logger.info { \"${it.count()} people from your contact have Birthday today\" } } .toList() private fun alreadyNotified(contact: Contact): Boolean = notificationService .findNotification(contact) .filter { notification -&gt; notification.time.toLocalDate().isToday() &amp;&amp; (notification.notification is BirthdayNotification) } .any() .also { alreadyNotified -&gt; if (alreadyNotified) logger.info { \"Already notified\" } } private fun recordMetric(failedCount: Int) { if (failedCount &gt; 0) metricService.measureCount(\"birthday.nofitication.failed.count\", failedCount) } private fun sendNotification(notification: BirthdayNotification): Result&lt;Unit&gt; = runCatching { notificationService.notify(notification) logger.info { \"Notified about birthday\" } } companion object { private fun LocalDate.isToday(): Boolean = this == LocalDate.now() }// other code down here." }, { "title": "Clear and honest code", "url": "/posts/clear-and-honest/", "categories": "Programming", "tags": "üëçrules", "date": "2023-08-12 00:00:00 +0530", "snippet": "When working with a huge code base, it‚Äôs common to forget how a specific code block (function, method, or class) is implemented. However, the IDE suggests using a signature. Sometimes calling a code block can come with unpleasant shocks. By creating honest and clear code blocks, this can be prevented.For example:// (account: Account, amount : BigDecimal) -&gt; Accountfun credit(account: Account, amount : BigDecimal): Account { if(amount &lt; ZERO) throw NegativeAmountError(amount) return account.copy(balance = account.balance + amount)}By looking at the signature, caller simply does‚Äôt know that it‚Äôs going to blow up. This kind of code blocks affect engineer in 2 ways Increases cognitive overload as caller has to read and understand the code block before using it. hampers the trust.Honest signature could have been something like(account: Account, amount : NonNegativeCurrency) -&gt; Account// or(account: Account, amount : BigDecimal) -&gt; Either&lt;NegativeAmountError, Account&gt;These 2 signatures appear quite straightforward, yet they use 2 different techniques. The first signature prevents entry into an incorrect state by forbidding negative input. While allowing erroneous input, the second signature communicates output more precisely. It informs the caller that it may provide an error or credit to their account.References Treat Type as set Read here and here Algebraic data type" }, { "title": "Code that changes together, stays together", "url": "/posts/code-that-stays-together/", "categories": "Programming", "tags": "Architecture, üëçrules", "date": "2022-08-02 00:00:00 +0530", "snippet": "In traditional clean/layered/onion architecture code is organized in layers and so as the abstractions such as controllers, services, repositories.What I have seen most of people do is tried to organize code per layer by structuring code around those layer.For example- src - controllers - services - use case - entities - repositoriesIn some projects, where I see team wanted to build modular monolith, they started to group based on some heuristic, that these pieces goes together probably we should modularize it.- src - module#1 - controllers - services - use case - entities - repositories - module#2 - controllers - services - use case - entities - repositoriesI consider this way of modularizing code base as premature as it suffers from forcing you to make decision when you the least knowledge about the system. Sometimes this kind of modularizing felt so artificial.So I was wondering ü§î how we could defer decision of making modularizing code structure as much as I can? How can I let code structure evolve itself organically?There was another problem, If I want to make any changes, I have to make changes in upon 4-5 different packages such as controller, services, use case. In lot of cases I felt that it‚Äôs lot of ceremony and dancing around so many files. There was urge of keeping things together.Suddenly something clicked ‚ÄúNeurons that fire together wire together‚Äù or ‚ÄúFamily thats eats together, stays together‚Äùwhich leads to Code thats changes together, stays togetherAs I move code which was changing together closer, 2 things happened Code thats was coming closer, coupling between them increased(on vertical access). Coupling between different slices started to dropAfter spending more time with this approach, I learned that code thats shared across slices bubbled up and moved into core of the feature or is a domain concept. or it‚Äôs just cross cutting concern. which then could moved up and finds it own place not just in code base but also conceptually.In summary this approach provide me following flexibilities Code structure can evolve as organically as with our understanding of the domain concepts. Provide a way be more pragmatic per slice. Provide way of grouping which can scale with growing feature sets.Final code structure was similar to üëáüèº- src - todo - api - dto - controller - find-todos - complete-todo - new-todo - todo - notes - api - dto - controller - new-notes - recent-notes - note" }, { "title": "Analogy with Lego", "url": "/posts/analogy-with-lego/", "categories": "Programming", "tags": "üëçrules", "date": "2022-07-26 00:00:00 +0530", "snippet": "The more I think about programming, the more I see lego. There is reason to that. I usually try to break down things to atomic levels from which it can‚Äôt be broken down into small things.In my childhood I used to do same with toy, pull out each piece and then put it back.So when I apply same things for programming, 2 things happens I creates lot of small pieces that can‚Äôt be broken down into smaller anymore I get enormous flexibility of building new things out it.See [[Creating lego blocks]]" }, { "title": "Atomic karma", "url": "/posts/atomic-karma/", "categories": "Stories", "tags": "PDü™¥, fractal", "date": "2022-06-16 00:00:00 +0530", "snippet": "Recently, I‚Äôm on Quest of finding fractal patterns in behavior. As part of this journey, I realized that Every action that I perform either consciously or unconsciously transform me on at least one dimension.For example, when I watch news, I have more knowledge and information but on other hand I have taken out attention. Such simple action affects me on those 2 dimensions. I do so many things on daily basis without putting much thought into it.If you look at every small things that you do and tally how it affects on dimensions that matters to you. You would have more clarity and probably you would able to get most of each atomic action performed.Let me list down some of these dimensions for me. Interest Time Attention Energy Fitness/health Financial Risk Joy Blissful Playful fulfilment Let me share my story about media consumption. I was spending hours and hours on it. After consuming media, I was left with less time, less energy and less attention to all other things that were important to me. It was not adding up on my dimensions.journey¬†¬†¬†¬†title¬†Media consumption¬†¬†¬†¬†interest:¬†5:¬†Me¬†¬†¬†¬†time:¬†2:¬†Me¬†¬†¬†¬†attention:¬†2:¬†Me¬†¬†¬†¬†energy:¬†1:¬†Me¬†¬†¬†¬†fitness:¬†1:¬†Me¬†¬†¬†¬†joy: 4: MeüëÜThis provides clear picture in my head what is that I‚Äôm getting out it.Need to do something:I reduced noise by reshaping social feeds such FB, twitter, linked-in, youtube and podcast. This lead into amplification of the original problem as now my feed is more interesting and giving more dose of dopamine üôÉ. So next I did was myself what can I do about interested thing? followed by five why ‚ùì Outcome of this led me understanding myself bit deeper. News (once a week only highlights) local news (5 minute on podcast as side) couple of episodes on tech and startup would (1 hour during commute or walking) 1/2 movies or series on Netflix/other streaming app whats app and other messaging app (2 to 3 times for less than 5 min)This whole process not on just gave more freedom but also started having incremental effect on each dimensions that mattered to me. This is also fractal by nature. You can apply it everything. A set of related action can form bigger action and meaningful action and vice versa." }, { "title": "My introduction to fsharp ü§ù", "url": "/posts/intro-to-fsharp/", "categories": "Stories", "tags": "functional programming, dotnet, fsharp", "date": "2022-06-12 00:00:00 +0530", "snippet": "I stumbled upon F# in around 2017. At that time I was new in Thoughtworks. It was overwhelming experience just by sheer size of learning on day to day basis. I was in the organization where folks out of TW universities has distilled knowledge of person working in software field for 5-6 years.What is it? ü§îDuring that time TW used to provide 3 problem statements for take-a-home assignment and applicant can choose any language that they are comfortable. Until that point I had only experience with .NET So I completed code challenge in C# and submitted.The next step was pair programming. After pair programming Krunal asked me one question before sharing feedback do you know functional programming?I said no, what is it?. He was surprised by answer as my most of the code was written in functional style and was heavily based on IEnumerable/IQueryable and Extensions .do you know fsharp?Fast forward after 10-12 months being in TW, I was having some conversations with Mushtaq and when I talked him about my past experience with .NET, first thing that he asked was ‚Äúdo you know fsharp?‚Äù. At that moment I decided to learn fsharp" }, { "title": "Nature, Impact and Value of Change", "url": "/posts/nature-impact-value-of-change/", "categories": "Lessons", "tags": "product, change", "date": "2022-02-15 15:30:00 +0530", "snippet": "In this article, I‚Äôm sharing lessons and learning about change. How understanding the nature, impact and value of change resulted in more clarity and confidence and helped me to prepare a release plan.Situation ü§∫Like my other colleagues, I also have been part of such Taskforce a couple of times. But recently in my task force, it was becoming very hard to come up with a proper release plan. We‚Äôre struggling to make a release plan which can be delivered incrementally and iteratively.Background üìúWhat is a Taskforce? ü§îAt layer, we form a triplet of Tech, Product and Business to refine features. Mostly one person from each area. Sometimes Product owner represents business expertise or acts as a proxy for business. For each epic people rotates from each area. This helps to create opportunities to learn, grow and avoid biases in the company. We called such a triplet Taskforce.The task force has the following responsibility üí™ Refine feature aka epic Be a point of contact for all the QA during crunch time. Prepare release planStill, the picture was not very clear in üß†We had a few brainstorming meetings but still picture was not very clear in our head; so I decided to analyse this epic critically and come up with some options.What we did ü§ûI decided to start from a clean slate and look at this feature from the user‚Äôs point of view. To do that I asked the following question for each concept and change that we wanted to bring in. What problem does it solves for the user? What problem it might create for the user? What is the nature of these changes? Breaking change - if it breaks or changes existing concept/feature drastically and changes affects user flow. New change - there were no such concepts that existed before in the system and it may or may not affect user flow. Enhancement - changes refine existing concepts but not so drastically and may not affect user flow.After doing this analysis and spending a few hours, I realized more than 70 % of changes were either enhancement or new changes and ~ 30 % were breaking changes. Just doing analysis unblocked a very big chunk of features and it brings a ton of clarity to my head.For breaking changes, I did one extra step I asked the same 3 questions for an existing feature to gain more clarity. After that, I knew exactly what we were taking out and giving back to the user. Now it was very easy to spot and fill the gaps.In summary, nature, impact and value of incoming changes is very useful in overall shaping up." }, { "title": "Fine control over execution in kotlin", "url": "/posts/fine-control-over-execution/", "categories": "Programming", "tags": "kotlin, concurrency and parallelism", "date": "2021-10-12 15:30:00 +0530", "snippet": "Programing language that supports concurrency and parallelism needs to provide cancellation mechanism as well. Well thought cancellation mechanism also gives space to clean up resources.In this blog post we‚Äôll take see how to cancel coroutine and impact of suspend functions on it.BasicsThe Job interface has a method called cancel, which allows to cancel the job.fun main() = runBlocking { val job = launch { repeat(1_00) { i -&gt; delay(200) println(\"printing $i\") } } delay(1_150) job.cancelAndJoin() println(\"cancelled successfully\")}// printing 0// printing 1// printing 2// printing 3// printing 4// cancelled successfullyCalling cancel has following effects on job. ends execution job at first suspension point if job has some children, they are also canceled at first suspension point Once job is canceled, it can not used as a parent for any new coroutines.Lets verify our first assumption by replacing delay call by Thread.sleepfun main() = runBlocking { val job = launch { repeat(1_00) { i -&gt; // delay(200) Thread.sleep(200) println(\"printing $i\") } } delay(1_150) job.cancelAndJoin() println(\"cancelled successfully\")}// what will be the outcome?// outcome:// printing 0// printing ..// printing 99// cancelled successfullyThread blocking codeOnce we removed delay function job has no suspension point and hence it continues to work until the end of computation. Thread.sleep is thread blocking functionlet‚Äôs extract repeat code block into suspended function.fun main() = runBlocking { val job = launch { repeat(1_00) { threadBlockingFn(it) } println(\"job completed\") } delay(1_150) job.cancelAndJoin() println(\"cancelled successfully\")}suspend fun threadBlockingFn(i: Int) = coroutineScope { Thread.sleep(200) println(\"printing $i\")}fun println(msg: Any) = with(Thread.currentThread()) { kotlin.io.println(\"$id:$name\\t=&gt; $msg\")}// what will be the outcome?// outcome:// 1:main\t=&gt; printing 0// 1:main\t=&gt; printing .. üßê// 1:main\t=&gt; printing 99 ü§î// 1:main\t=&gt; job completed// 1:main\t=&gt; cancelled successfullyjob is running on single thread and even we have suspended function threadBlockingFn main thread does not get unblocked to observe cancellation request. So how to create suspension point in this case?In order to have more fine control, lets create coroutine for every call of threadBlockFn and join it back with parent jobfun main() = runBlocking { val job = launch { repeat(1_00) { launch { threadBlockingFn(it) }.join() } // also produces same output // repeat(1_00) { async { threadBlockingFn(it) }.await() } println(\"job completed\") } delay(1_150) job.cancelAndJoin() println(\"cancelled successfully\")}// output:// 1:main\t=&gt; printing 0// 1:main\t=&gt; printing 1// 1:main\t=&gt; printing 2// 1:main\t=&gt; printing 3// 1:main\t=&gt; printing 4// 1:main\t=&gt; printing 5// 1:main\t=&gt; cancelled successfullyLets use default dispatcher to delegate threadBlockFn executionfun main() = runBlocking { val job = launch { repeat(1_00) { withContext(Dispatchers.Default) { threadBlockingFn(it) } } println(\"job completed\") } delay(1_150) job.cancelAndJoin() println(\"cancelled successfully\")}// output:// 14:DefaultDispatcher-worker-1\t=&gt; printing 0// 14:DefaultDispatcher-worker-1\t=&gt; printing 1// 14:DefaultDispatcher-worker-1\t=&gt; printing 2// 14:DefaultDispatcher-worker-1\t=&gt; printing 3// 14:DefaultDispatcher-worker-1\t=&gt; printing 4// 14:DefaultDispatcher-worker-1\t=&gt; printing 5// 1:main\t=&gt; cancelled successfullySummaryCoroutine, dispatcher along with suspended functions provides very powerful mechanism to have full control over execution of code blocks. Default function such as delay are cancel aware functions.To summarize, I would say use following thumb rules to achieve fine controlled code Have more suspension points in code base Avoid thread blocking code areas coroutines are very lightweight, use them more frequently use async/await, withContext around appropriate spaces Break down computation heavy operation into smaller pieces with more suspension points" }, { "title": "Any, Unit and Nothing", "url": "/posts/usecases-of-any-unit-nothing/", "categories": "Programming", "tags": "kotlin, domain modeling", "date": "2021-04-28 00:00:00 +0530", "snippet": "This article explain basic difference between Any, Unit and Nothing from kotlin language.AnyAny is by default the superclass of all the classes and has 3 functions: equals, hashCode and toString. This is equal to Object class in Java.We can create an object of Any class directly or even override these functions in any other class.public open class Any { public open operator fun equals(other: Any?): Boolean public open fun hashCode(): Int public open fun toString(): String}UnitUnit class is a singleton class and also is an object, we can‚Äôt extend or even create an another object of it.Unit class in equal to void type in Java.The superclass of Unit is Any and it has overridden toString method.public object Unit { override fun toString() = \"kotlin.Unit\"}NothingNothing is non-open (final class) which can‚Äôt be extended and its constructor is also private that means we can‚Äôt create the object also.This is usually used to represent the return type of function which will always throw an exception.The superclass of Nothing is Any.public class Nothing private constructor()" }, { "title": "Modelling value types in kotlin", "url": "/posts/modelling-value-types/", "categories": "Programming", "tags": "kotlin, domain modeling", "date": "2020-11-04 05:30:00 +0530", "snippet": "In this article, you‚Äôll see how to model value object particularly in kotlin.Imagine we want to improve below model:class Customer(id: UUID, email: String,..)class Order(id: UUID,..)I had 2 use reason for modelling value typeType safetylots of time I want to distinguish between let‚Äôs say customerId and orderIdso that accidental passing of wrong Id can be avoided.the best way is use inline class 1 concept but be carefulwith it‚Äôs stability status.// option #1inline class CustomerId(val value: UUID)// option #2data class CustomerId(val value: UUID)// option #3data class CustomerId(private val value: UUID) { override fun toString(): String = value.toString() fun asString(): String = value.toString() fun asUUID(): UUID = value}Option 1 and 2 are more recommended where as option #3 is example of over modelling. I often have tendency to make props as private by default. but when we‚Äôre modelling immutable data type.You don‚Äôt need to mark props as private.Represent a domain concept with constraintLet‚Äôs take an example of email which need to match some fancy regex.This is bit complicated one especially with kotlin because of language design.But we have 3 options here: Use constructor to throw violations üòü data class Email(val value: String) { init { // if (!isValid(value)) // then throw InvalidEmail() } } This option is not bad but it has few limitations and such as constructor is not honest enough because it can blew on your face it can hijack your program‚Äôs execution don‚Äôt use kotlin since well-known design flaw 2 üòÖ Use NoCopy plugin üéØ There is really nice article about NoCopy hereSummaryKotlin has few limitations but those can be fixed. Always go for more transparent and honest representation. https://kotlinlang.org/docs/reference/evolution/components-stability.html#current-stability-of-kotlin-components ‚Äúinline class is at Alpha stability level‚Äù¬†&#8617; https://youtrack.jetbrains.com/issue/KT-11914 ‚ÄúConfusing data class copy with private constructor‚Äù¬†&#8617; " }, { "title": "Introduction to Http4k", "url": "/posts/introduction-to-http4/", "categories": "Programming", "tags": "toolkit, kotlin, functional programming", "date": "2020-01-27 15:22:21 +0530", "snippet": "Couple of weeks ago, I was looking for very simple way to create web server.I found http4k which is a lightweight but fully-featured HTTP toolkitwritten in pure Kotlin that enables the serving and consuming of HTTP servicesin a functional and consistent way.Some of Features of http4k small, written in functional kotlin with zero dependencies. very simple, no magic, no reflections. immutable http model, which make it very easy to test/debug. serverless / server independentWebServer as Functionhttp4k is designed as application as function.Web server can be looked as one big function which handles requests.so it‚Äôs literally represented as typealiastypealias HttpHandler = (HttpRequest) -&gt; HttpResponseAn endpoint which echos request body can be created just by 2 simple lines.val app: HttpHandler = { request: Request -&gt; Response(OK).body(request.body)}val server = app.asServer(SunHttp(8000)).start()Request and Response are immutable objects.SunHttp is container which only meant for development.For production use Netty, Jetty, ApacheServer etc.Because app is just kotlin function, it can be composed very easily.Filtershttp4k provides a Filter function which is basicallyto intercept the Request/Response pipeline.typealias Filter = (HttpHandler) -&gt; HttpHandlerBelow code snippet shows typical composition of HttpHandlers.val setContentType = Filter { nextHandler -&gt; { request -&gt; nextHandler(request) .header(\"Content-Type\", \"text/plain\") } }val composedApp = setContentType.then(app)Routing and compositionhttp4k provides some high level functions which helps to compose applicationwhich handles each request differently depending upon url, method etc.These functions accepts multiple httpHandlers and return composed handler.val app : HttpHandler = routes( \"/api\" bind GET to apiApp \"/other\" bind routes( \"/get\" bind GET to {_:Request -&gt; Response(OK)} \"/post\" bind POST to otherPostHandlerFn ))Conclusionhttp4k really stands with the promises they made.API from http4 are written very thoughtfully and are not opinionated.They are easy to reason and work with.Only downside can be no support for coroutine.To know more about http4k rationale visit http4k/rationale" } ]
