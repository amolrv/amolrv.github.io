---
categories: [Programming]
title: Harnessing power of multi-paradigm
date: 2023-09-07
tags: []
---

Modern languages such as F#, Swift, Rust, and Kotlin support multiple programming paradigms, allowing developers to leverage the strengths of different approaches.

Rust: combines imperative, functional, and object-oriented paradigms.
Swift: supports imperative and object-oriented programming paradigms and incorporates functional programming features.
Kotlin: supports object-oriented and functional programming paradigms.

Please note each language varies in the degree to which it supports a given paradigm and might have its own nuances.

Programming paradigms:

1. Declarative
   1. **Functional**
   2. Logic
   3. Reactive
2. Imperative
   1. Procedural
   2. **Object Oriented**

The declarative paradigm focuses on _what_ rather than _how_. This one thing alone brings a ton of benefits to the table. It becomes even more powerful when fused with:

- [Clear and honest code block](../clear-and-honest)
- Single responsibility principle
- Composition
- Immutability

Imperative coding style focuses on _how_ rather than _what_.

- Offers greater control over each step
- Less indirection

Let's take a simple example in Kotlin.

```kotlin
class BirthdayNotifier(
  private val contactService: ContactService,
  private val notificationService: NotificationService,
  private val metricService: MetricService
) {

  fun notify(user: UUID) {
    val birthdayBuddies = contactService.findFriendsOf(user)
      .filter { contact -> contact.birthDate?.isToday() ?: false }
      .also { logger.info { "${it.count()} people from your contact have Birthday today" } }
      .toList()

    var failedToNotify = 0

    birthdayBuddies.forEach { contact ->
      try {
        val isAlreadyNotified = notificationService
          .findNotification(contact)
          .filterNot { notification ->
            notification.time.toLocalDate().isToday()
              && (notification.notification is BirthdayNotification)
          }
          .any()

        if (isAlreadyNotified) logger.info { "Already notified" }
        else {
          val notification = BirthdayNotification.from(contact)
          notificationService.notify(notification)
          logger.info { "Notified about birthday" }
        }

      } catch (ex: Throwable) {
        logger.error(ex) { "Failed to notify contact $contact" }
        failedToNotify += 1
      }
    }
    if (failedToNotify > 0) metricService.measureCount("birthday.notification.failed.count", failedToNotify)
  }
}
```

The author of code naturally gravitates towards "how to do things" rather than "what are we doing here" during the writing phase, whereas the reader always seeks "what are we doing here" and wants to form a mental model of the system. Once we understand the objectives of authors and readers, we can address their needs accordingly. We can use declarative style when _what_ is more important than _how_. When it's about doing one thing and the main question is about _how_ rather than _what_, then go for imperative style and keep the focus on efficiency.

Now let's look at the above example by zooming out a little bit. We'll see we're:

- Finding buddies who have birthdays and who aren't yet notified
- Once we find such buddies, we're notifying them
- Lastly, reporting the failed-to-notify count

But the above code does not look or speak this clearly. Let's write code at this level of abstraction and see how it looks.

```kotlin
// other code

fun notify(user: UUID) {
    birthdayBuddiesOf(user)
      .filterNot(::alreadyNotified)
      .map(::BirthdayNotification)
      .map(::sendNotification)
      .let { notificationResults -> notificationResults.count { it.isFailure } }
      .also(::recordMetric)
}

private fun birthdayBuddiesOf(userId: UUID): List<Contact> =
  contactService.findFriendsOf(userId)
    .filter { contact -> contact.birthDate?.isToday() ?: false }
    .also { logger.info { "${it.count()} people from your contact have Birthday today" } }
    .toList()

private fun alreadyNotified(contact: Contact): Boolean =
  notificationService
    .findNotification(contact)
    .filter { notification ->
      notification.time.toLocalDate().isToday() && (notification.notification is BirthdayNotification)
    }
    .any()
    .also { alreadyNotified -> if (alreadyNotified) logger.info { "Already notified" } }

private fun recordMetric(failedCount: Int) {
  if (failedCount > 0) metricService.measureCount("birthday.notification.failed.count", failedCount)
}

private fun sendNotification(notification: BirthdayNotification): Result<Unit> =
  runCatching {
    notificationService.notify(notification)
    logger.info { "Notified about birthday" }
  }

companion object {
  private fun LocalDate.isToday(): Boolean = this == LocalDate.now()
}
// other code down here.
```

To summarize, mixing different paradigms can lead to better code. Here we're mixing object-oriented and functional paradigms together to make code more readable.
